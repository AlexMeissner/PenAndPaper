@using DataTransfer.Map
@using DataTransfer.Mouse
@using DataTransfer.Token
@using DataTransfer.Types
@using Website.Converter
@using Website.Services
@using Website.Services.API
@using Website.Services.Graphics

@inject IMapApi MapApi
@inject IMouseApi MouseApi
@inject IActiveMapApi ActiveMapApi
@inject ITokenApi TokenApi
@inject RenderContext RenderContext
@inject ICampaignEvents CampaignEvents
@inject ILogger<Map> Logger

@implements IDisposable

<canvas id="@CanvasId"
        class="render-context"
        @onmousemove="OnMouseMove"
        @onmousedown="OnMouseButtonChanged"
        @onmouseup="OnMouseButtonChanged"
        @onmouseleave="OnMouseLeave">
</canvas>

<script>
    const canvas = document.getElementById("renderCanvas");
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    window.addEventListener("resize", () => {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
    });
</script>

@code {
    [Parameter] public int CampaignId { get; set; }

    private int _gridSize;
    private Vector2D _selectedTokenPosition = new Vector2D(0, 0);
    private Token? _selectedToken;
    private TexturedQuad? _texturedQuad;
    private MouseIndicator? _mouseIndicator;
    private ShaderProgram? _mapShaderProgram;
    private ShaderProgram? _tokenShaderProgram;
    private ShaderProgram? _mouseShaderProgram;

    private readonly List<Token> _tokens = [];

    const long LeftMouseButton = 1;
    private static readonly string CanvasId = "renderCanvas";

    public void Dispose()
    {
        CampaignEvents.MapChanged -= OnMapChanged;
        CampaignEvents.MouseMoved -= OnMouseMoved;
        CampaignEvents.TokenMoved -= OnTokenMoved;
    }

    protected override void OnInitialized()
    {
        CampaignEvents.MapChanged += OnMapChanged;
        CampaignEvents.MouseMoved += OnMouseMoved;
        CampaignEvents.TokenMoved += OnTokenMoved;
    }

    private async Task OnMapChanged(MapChangedEventArgs e)
    {
        await LoadActiveMap(e.MapId);
        await LoadTokens(e.MapId);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await RenderContext.Initialize(CanvasId);
            await LoadMapShaderProgram();
            await LoadTokenShaderProgram();
            await LoadMouseShaderProgram();

            _mouseIndicator = await CreateMouseIndicator();
            await RenderContext.AddMouseIndicator(_mouseIndicator);

            if (await GetActiveMapId() is { } mapId)
            {
                await LoadActiveMap(mapId);
                await LoadTokens(mapId);
            }
        }
    }

    private async Task LoadMapShaderProgram()
    {
        var vertexSource = await ResourceReader.GetAsync("Map.vert");
        var fragmentSource = await ResourceReader.GetAsync("Map.frag");

        _mapShaderProgram = await RenderContext.CreateShaderProgram();

        var hasSucceeded = await _mapShaderProgram.Compile(vertexSource, fragmentSource);

        if (!hasSucceeded)
        {
            Logger.LogError("Failed to compile map shader");
        }

        var cameraBuffer = await RenderContext.GetCamera();
        await _mapShaderProgram.AddUniformBuffer(cameraBuffer);

        var gridBuffer = await RenderContext.GetGrid();
        await _mapShaderProgram.AddUniformBuffer(gridBuffer);
    }

    private async Task LoadTokenShaderProgram()
    {
        var vertexSource = await ResourceReader.GetAsync("Token.vert");
        var fragmentSource = await ResourceReader.GetAsync("Token.frag");

        _tokenShaderProgram = await RenderContext.CreateShaderProgram();

        var hasSucceeded = await _tokenShaderProgram.Compile(vertexSource, fragmentSource);

        if (!hasSucceeded)
        {
            Logger.LogError("Failed to compile map shader");
        }

        var cameraBuffer = await RenderContext.GetCamera();
        await _tokenShaderProgram.AddUniformBuffer(cameraBuffer);

        var gridBuffer = await RenderContext.GetGrid();
        await _tokenShaderProgram.AddUniformBuffer(gridBuffer);
    }

    private async Task LoadMouseShaderProgram()
    {
        var vertexSource = await ResourceReader.GetAsync("Mouse.vert");
        var fragmentSource = await ResourceReader.GetAsync("Mouse.frag");

        _mouseShaderProgram = await RenderContext.CreateShaderProgram();

        var hasSucceeded = await _mouseShaderProgram.Compile(vertexSource, fragmentSource);

        if (!hasSucceeded)
        {
            Logger.LogError("Failed to compile map shader");
        }

        var cameraBuffer = await RenderContext.GetCamera();
        await _mouseShaderProgram.AddUniformBuffer(cameraBuffer);
    }

    private async Task LoadActiveMap(int mapId)
    {
        var map = await GetMapData(mapId);

        if (map is null) return;

        var dimensions = ByteArrayToImageSizeConverter.Convert(map.ImageData);

        float[] vertices =
        [
            0.0f, 0.0f,
            dimensions.Width, 0.0f,
            0.0f, -dimensions.Height,
            dimensions.Width, -dimensions.Height
        ];

        if (_texturedQuad is null)
        {
            _texturedQuad = await RenderContext.CreateTexturedQuad();
            await _texturedQuad.SetVertices(vertices);
        }
        else
        {
            await _texturedQuad.UpdateVertices(vertices);
        }

        if (map.ImageData.Length > 0)
        {
            await _texturedQuad.SetTexture(map.ImageData);
        }

        if (_mapShaderProgram is not null)
        {
            await _texturedQuad.SetShaderProgram(_mapShaderProgram);
        }

        await RenderContext.SetMap(_texturedQuad);

        float[] color = [0.0f, 0.0f, 0.0f, 1.0f];
        await RenderContext.UpdateGrid(map.Grid.IsActive, map.Grid.Size, color);

        _gridSize = map.Grid.Size;
    }

    private async Task<MouseIndicator> CreateMouseIndicator()
    {
        const float halfSize = 25.0f;
        float[] vertices =
        [
            -halfSize, halfSize,
            halfSize, halfSize,
            -halfSize, -halfSize,
            halfSize, -halfSize
        ];

        var mouseIndicator = await RenderContext.CreateMouseIndicator();
        await mouseIndicator.SetVertices(vertices);

        if (_mouseShaderProgram is not null)
        {
            await mouseIndicator.SetShaderProgram(_mouseShaderProgram);
        }

        return mouseIndicator;
    }

    private async Task LoadTokens(int mapId)
    {
        var response = await TokenApi.GetAsync(mapId);

        var tokens = response.Match(
            tokens => tokens.Items,
            statusCode =>
            {
                Logger.LogError("Failed to get the tokens for map {mapId} ({statusCode})", mapId, statusCode);
                return [];
            });

        await RenderContext.ClearTokens();
        _tokens.Clear();

        float[] vertices =
        [
            0.0f, 0.0f,
            1.0f, 0.0f,
            0.0f, -1.0f,
            1.0f, -1.0f
        ];

        foreach (var tokenItem in tokens)
        {
            var token = await RenderContext.CreateToken();
            token.Id = tokenItem.Id;

            await token.SetVertices(vertices);
            await token.SetTexture(tokenItem.Image);

            if (_tokenShaderProgram is not null)
            {
                await token.SetShaderProgram(_tokenShaderProgram);
            }

            await token.SetUniform("x", tokenItem.X);
            await token.SetUniform("y", tokenItem.Y);

            await RenderContext.AddToken(token);
            _tokens.Add(token);
        }
    }

    private async Task OnMouseButtonChanged(MouseEventArgs e)
    {
        _selectedToken = null;

        if (e.Buttons == LeftMouseButton)
        {
            foreach (var token in _tokens)
            {
                if (await token.GetUniform("isMouseOver") == 1.0f)
                {
                    var position = new Vector2D(e.ClientX, e.ClientY);
                    var transformedPosition = await RenderContext.TransformPosition(position);
                    _selectedTokenPosition = GetGridSnapPosition(transformedPosition);
                    _selectedToken = token;
                    break;
                }
            }
        }
    }

    private void OnMouseLeave(MouseEventArgs e)
    {
        _selectedToken = null;
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (e.Buttons == LeftMouseButton)
        {
            var position = new Vector2D(e.ClientX, e.ClientY);
            var transformedPosition = await RenderContext.TransformPosition(position);

            if (_selectedToken is null)
            {
                var color = new Vector3D(0.8, 0.4, 0.6);
                var payload = new MouseMoveEventArgs(transformedPosition, color);
                await MouseApi.PostAsync(payload);
            }
            else
            {
                var snapPosition = GetGridSnapPosition(transformedPosition);

                if (snapPosition.X != _selectedTokenPosition.X || snapPosition.Y != _selectedTokenPosition.Y)
                {
                    var payload = new TokenUpdateDto(CampaignId, _selectedToken.Id, (int)snapPosition.X, (int)snapPosition.Y);
                    await TokenApi.PutAsync(payload);
                    _selectedTokenPosition = snapPosition;
                }
            }
        }
    }

    private async Task OnMouseMoved(MouseMoveEventArgs e)
    {
        await _mouseIndicator!.SetPosition(e.Position);
    }

    private async Task OnTokenMoved(TokenMovedEventArgs e)
    {
        if (_tokens.Find(x => x.Id == e.TokenId) is { } token)
        {
            await token.SetUniform("x", e.X);
            await token.SetUniform("y", e.Y);
        }
    }

    private Vector2D GetGridSnapPosition(Vector2D position)
    {
        var x = (int)position.X / _gridSize * _gridSize;
        var y = (int)position.Y / _gridSize * _gridSize;
        return new Vector2D(x, y);
    }

    private async Task<int?> GetActiveMapId()
    {
        var response = await ActiveMapApi.GetAsync(CampaignId);

        return response.Match(
            activeMap => activeMap.MapId,
            statusCode =>
            {
                Logger.LogError("Failed to get the active map ({statusCode})", statusCode);
                return null;
            });
    }

    private async Task<MapDto?> GetMapData(int mapId)
    {
        var response = await MapApi.GetAsync(mapId);

        return response.Match<MapDto?>(
            map => map,
            statusCode =>
            {
                Logger.LogError("Failed to get map data ({statusCode})", statusCode);
                return null;
            });
    }

}