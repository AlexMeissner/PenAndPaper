@using DataTransfer.Map
@using DataTransfer.Mouse
@using DataTransfer.Types
@using Website.Converter
@using Website.Services
@using Website.Services.API
@using Website.Services.Graphics

@inject IMapApi MapApi
@inject IMouseApi MouseApi
@inject IActiveMapApi ActiveMapApi
@inject ITokenApi TokenApi
@inject RenderContext RenderContext
@inject ICampaignEvents CampaignEvents
@inject ILogger<Map> Logger

@implements IDisposable

<canvas id="@CanvasId" class="render-context" @onmousemove="OnMouseMove"></canvas>

<script>
    const canvas = document.getElementById("renderCanvas");
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    window.addEventListener("resize", () => {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
    });
</script>

@code {
    [Parameter] public int CampaignId { get; set; }

    private TexturedQuad? _texturedQuad;
    private ShaderProgram? _mapShaderProgram;
    private ShaderProgram? _tokenShaderProgram;

    private static readonly string CanvasId = "renderCanvas";

    public void Dispose()
    {
        CampaignEvents.MapChanged -= OnMapChanged;
        CampaignEvents.MouseMoved -= OnMouseMoved;
    }

    protected override void OnInitialized()
    {
        CampaignEvents.MapChanged += OnMapChanged;
        CampaignEvents.MouseMoved += OnMouseMoved;
    }

    private async Task OnMapChanged(MapChangedEventArgs e)
    {
        await LoadActiveMap(e.MapId);
        await LoadTokens(e.MapId);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await RenderContext.Initialize(CanvasId);
            await LoadMapShaderProgram();
            await LoadTokenShaderProgram();

            if (await GetActiveMapId() is { } mapId)
            {
                await LoadActiveMap(mapId);
                await LoadTokens(mapId);
            }
        }
    }

    private async Task LoadMapShaderProgram()
    {
        var vertexSource = await ResourceReader.GetAsync("Map.vert");
        var fragmentSource = await ResourceReader.GetAsync("Map.frag");

        _mapShaderProgram = await RenderContext.CreateShaderProgram();

        var hasSucceeded = await _mapShaderProgram.Compile(vertexSource, fragmentSource);

        if (!hasSucceeded)
        {
            Logger.LogError("Failed to compile map shader");
        }

        var cameraBuffer = await RenderContext.GetCamera();
        await _mapShaderProgram.AddUniformBuffer(cameraBuffer);

        var gridBuffer = await RenderContext.GetGrid();
        await _mapShaderProgram.AddUniformBuffer(gridBuffer);
    }

    private async Task LoadTokenShaderProgram()
    {
        var vertexSource = await ResourceReader.GetAsync("Token.vert");
        var fragmentSource = await ResourceReader.GetAsync("Token.frag");

        _tokenShaderProgram = await RenderContext.CreateShaderProgram();

        var hasSucceeded = await _tokenShaderProgram.Compile(vertexSource, fragmentSource);

        if (!hasSucceeded)
        {
            Logger.LogError("Failed to compile map shader");
        }

        var cameraBuffer = await RenderContext.GetCamera();
        await _tokenShaderProgram.AddUniformBuffer(cameraBuffer);

        var gridBuffer = await RenderContext.GetGrid();
        await _tokenShaderProgram.AddUniformBuffer(gridBuffer);
    }

    private async Task LoadActiveMap(int mapId)
    {
        var map = await GetMapData(mapId);

        if (map is null) return;

        var dimensions = ByteArrayToImageSizeConverter.Convert(map.ImageData);

        float[] vertices =
        [
            0.0f, 0.0f,
            dimensions.Width, 0.0f,
            0.0f, -dimensions.Height,
            dimensions.Width, -dimensions.Height
        ];

        if (_texturedQuad is null)
        {
            _texturedQuad = await RenderContext.CreateTexturedQuad();
            await _texturedQuad.SetVertices(vertices);
        }
        else
        {
            await _texturedQuad.UpdateVertices(vertices);
        }

        if (map.ImageData.Length > 0)
        {
            await _texturedQuad.SetTexture(map.ImageData);
        }

        if (_mapShaderProgram is not null)
        {
            await _texturedQuad.SetShaderProgram(_mapShaderProgram);
        }

        await RenderContext.SetMap(_texturedQuad);

        float[] color = [0.0f, 0.0f, 0.0f, 1.0f];
        await RenderContext.UpdateGrid(map.Grid.IsActive, map.Grid.Size, color);
    }

    private async Task LoadTokens(int mapId)
    {
        var response = await TokenApi.GetAsync(mapId);

        var tokens = response.Match(
            tokens => tokens.Items,
            statusCode =>
            {
                Logger.LogError("Failed to get the tokens for map {mapId} ({statusCode})", mapId, statusCode);
                return [];
            });

        await RenderContext.ClearTokens();

        float[] vertices =
        [
            0.0f, 0.0f,
            1.0f, 0.0f,
            0.0f, -1.0f,
            1.0f, -1.0f
        ];

        foreach (var token in tokens)
        {
            var quad = await RenderContext.CreateToken();
            await quad.SetVertices(vertices);
            await quad.SetTexture(token.Image);

            if (_tokenShaderProgram is not null)
            {
                await quad.SetShaderProgram(_tokenShaderProgram);
            }

            await quad.SetUniform("x", token.X);
            await quad.SetUniform("y", token.Y);

            await RenderContext.AddToken(quad);
        }
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        const long leftMouseButton = 1;

        if (e.Buttons == leftMouseButton)
        {
            var position = new Vector2D(e.ClientX, e.ClientY);
            var color = new Vector3D(0.8, 0.4, 0.6);
            var payload = new MouseMoveEventArgs(position, color);
            await MouseApi.PostAsync(payload);
        }
    }

    private async Task OnMouseMoved(MouseMoveEventArgs e)
    {
        Console.WriteLine("Mouse Moved");
    }

    private async Task<int?> GetActiveMapId()
    {
        var response = await ActiveMapApi.GetAsync(CampaignId);

        return response.Match(
            activeMap => activeMap.MapId,
            statusCode =>
            {
                Logger.LogError("Failed to get the active map ({statusCode})", statusCode);
                return null;
            });
    }

    private async Task<MapDto?> GetMapData(int mapId)
    {
        var response = await MapApi.GetAsync(mapId);

        return response.Match<MapDto?>(
            map => map,
            statusCode =>
            {
                Logger.LogError("Failed to get map data ({statusCode})", statusCode);
                return null;
            });
    }

}